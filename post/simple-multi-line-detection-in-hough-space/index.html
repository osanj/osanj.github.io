<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-us" lang="en-us">
<head>
  <link href="//gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="generator" content="Hugo 0.92.2" />

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>A Simple Method for Finding Multiple Lines in a Hough Space &middot; Just a Notepad</title>

  
  <link type="text/css" rel="stylesheet" href="https://osanj.github.io/css/print.css" media="print">
  <link type="text/css" rel="stylesheet" href="https://osanj.github.io/css/poole.css">
  <link type="text/css" rel="stylesheet" href="https://osanj.github.io/css/syntax.css">
  <link type="text/css" rel="stylesheet" href="https://osanj.github.io/css/hyde.css">
  
  <link type="text/css" rel="stylesheet" href="https://osanj.github.io/css/justified_text.css">
  
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Abril+Fatface|PT+Sans:400,400i,700">


  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-144-precomposed.png">
  <link rel="shortcut icon" href="/favicon.png">

  
  

  
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/katex.min.css" integrity="sha384-zh0CIslj+VczCZtlzBcjt5ppRcsAmDnRem7ESsYwWwg3m/OaJ2l4x7YBZl9Kxxib" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/katex.min.js" integrity="sha384-Rma6DA2IPUwhNxmrB/7S3Tno0YY7sFu9WSYMCuulLhIqYSGZ2gKCJWIqhBWqMQfh" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/contrib/auto-render.min.js" integrity="sha384-hCXGrW6PitJEwbkoStFjeJxv+fSOOQKOPbJxSfM6G5sWZjAyWhXiTIIAmQqnlLlh" crossorigin="anonymous"></script>
<script>
    document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement(document.body, {
          
          
          delimiters: [
              {left: '$$', right: '$$', display: true},
              {left: '$', right: '$', display: false},
              {left: '\\(', right: '\\)', display: false},
              {left: '\\[', right: '\\]', display: true}
          ],
          
          throwOnError : false
        });
    });
</script>

  
</head>

  <body class=" ">
  <aside class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <a href="https://osanj.github.io/"><h1>Just a Notepad</h1></a>
      <p class="lead">
       For Stuff Worth Sharing 
      </p>
    </div>

    <nav>
      <ul class="sidebar-nav">
        <li><a href="https://osanj.github.io/">Home</a> </li>
        <li><a href="https://github.com/osanj/lava"> Lava </a></li><li><a href="/tags/"> Tags </a></li><li><a href="/about/"> About </a></li>
      </ul>
    </nav>

    <p>¬© 2020-2025 Jonas Schuepfer</p>
  </div>
</aside>

    <main class="content container">
    <div class="post">
  <h1>A Simple Method for Finding Multiple Lines in a Hough Space</h1>
  <time datetime=2022-12-29T00:00:00Z class="post-date">Thu, Dec 29, 2022</time>
  <p>Detecting the longest line in an Hough accumulator is easy, however detecting multiple lines is a more annoying problem.</p>
<h3 id="hough-transform-recap">Hough Transform Recap</h3>
<p>The Hough transform is a brute force method for line detection. In simple terms for each given non-zero pixel in a binarized image it generates all possible lines and counts (&ldquo;votes&rdquo;) how often each line occurs. To this end lines are represented in <a href="https://en.wikipedia.org/wiki/Line_(geometry)#Hesse_normal_form">normal form</a>:</p>
<p>$$
\rho = x \cos \theta + y \sin \theta
$$</p>
<p>For implementation a set of discrete values for $\rho$ and $\theta$ are chosen and using the above formula the corresponding $\rho$ values are computed and discretized. Then, in an accumulator array that represents the possible line configurations, votes are collected. The more votes a set of parameters $(\rho, \theta)$ has, the more points in the binarized image lay on this line.</p>
<p>An efficient numpy implementation is given below:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Python" data-lang="Python"><span style="color:#a6e22e">@dataclass</span>
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">HoughAccumulator</span>:
    row_index_to_rho: Sequence[float]
    col_index_to_theta_rad: Sequence[float]
    rho_resolution: float
    theta_resolution: float
    votes: npt<span style="color:#f92672">.</span>NDArray[np<span style="color:#f92672">.</span>int32]

    <span style="color:#75715e"># ... see full script for more methods</span>

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">add_votes</span>(self, binarized_image: npt<span style="color:#f92672">.</span>NDArray[np<span style="color:#f92672">.</span>uint8]) <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">None</span>:

        <span style="color:#75715e"># get indices of non-zero pixels</span>
        y_indices, x_indices <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>indices(binarized_image<span style="color:#f92672">.</span>shape)
        mask <span style="color:#f92672">=</span> binarized_image <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>
        x <span style="color:#f92672">=</span> x_indices[mask]<span style="color:#f92672">.</span>reshape(<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>)
        y <span style="color:#f92672">=</span> y_indices[mask]<span style="color:#f92672">.</span>reshape(<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>)
        n <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>prod(x<span style="color:#f92672">.</span>shape)

        <span style="color:#75715e"># setup theta array in a way that in a single operation</span>
        <span style="color:#75715e"># thetas are computed for all pixels</span>
        <span style="color:#75715e"># (each pixel needs to be combined with all thetas)</span>
        theta_count <span style="color:#f92672">=</span> len(self<span style="color:#f92672">.</span>col_index_to_theta_rad)
        thetas <span style="color:#f92672">=</span> (np<span style="color:#f92672">.</span>tile(self<span style="color:#f92672">.</span>col_index_to_theta_rad, n)
                  <span style="color:#f92672">.</span>reshape(n, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>))
        theta_indices <span style="color:#f92672">=</span> (np<span style="color:#f92672">.</span>tile(np<span style="color:#f92672">.</span>arange(theta_count), n)
                         <span style="color:#f92672">.</span>reshape(n, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)<span style="color:#f92672">.</span>astype(np<span style="color:#f92672">.</span>int32))

        <span style="color:#75715e"># based on the normal form equation rho can be computed</span>
        <span style="color:#75715e"># afterward it needs to be discretized to match</span>
        <span style="color:#75715e"># the accumulator resolution</span>
        rho_count <span style="color:#f92672">=</span> len(self<span style="color:#f92672">.</span>row_index_to_rho)
        rho_values <span style="color:#f92672">=</span> x <span style="color:#f92672">*</span> np<span style="color:#f92672">.</span>cos(thetas) <span style="color:#f92672">+</span> y <span style="color:#f92672">*</span> np<span style="color:#f92672">.</span>sin(thetas)
        rho_indices <span style="color:#f92672">=</span> (np<span style="color:#f92672">.</span>around(rho_values <span style="color:#f92672">/</span> self<span style="color:#f92672">.</span>rho_resolution)
                       <span style="color:#f92672">.</span>astype(np<span style="color:#f92672">.</span>int32))

        <span style="color:#75715e"># out of bounds indices are ignored</span>
        <span style="color:#75715e"># 2d indices are converted to 1d, so counting is simple</span>
        <span style="color:#75715e"># finally the accumulator is updated with the counted votes</span>
        rho_indices_flat <span style="color:#f92672">=</span> rho_indices<span style="color:#f92672">.</span>flatten()
        theta_indices_flat <span style="color:#f92672">=</span> theta_indices<span style="color:#f92672">.</span>flatten()
        flat_mask <span style="color:#f92672">=</span> ((rho_indices_flat <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>) <span style="color:#f92672">&amp;</span>
                     (rho_indices_flat <span style="color:#f92672">&lt;</span> rho_count) <span style="color:#f92672">&amp;</span>
                     (theta_indices_flat <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>) <span style="color:#f92672">&amp;</span>
                     (theta_indices_flat <span style="color:#f92672">&lt;</span> theta_count))
        flat_indices <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>ravel_multi_index(
            (rho_indices_flat[flat_mask],
             theta_indices_flat[flat_mask]),
            self<span style="color:#f92672">.</span>votes<span style="color:#f92672">.</span>shape
        )
        counts <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>bincount(flat_indices)
        counts_mask <span style="color:#f92672">=</span> counts <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>
        idx <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>arange(len(counts))
        self<span style="color:#f92672">.</span>votes<span style="color:#f92672">.</span>flat[idx[counts_mask]] <span style="color:#f92672">+=</span> counts[counts_mask]</code></pre></div>
<h3 id="so-whats-the-deal">So What&rsquo;s the Deal?</h3>
<p>When finding the longest (&ldquo;strongest&rdquo;) line in the Hough space, it&rsquo;s rather easy. With argmax the corresponding $\rho_{argmax}$ and $\theta_{argmax}$ can be found.</p>
<p>However, when multiple lines are supposed to be detected, things get a bit more complicated. Typically points in a binarized image are contributing to multiple lines in vicinity of the true line, so the signal in the Hough space is not a single entry. Lines are local maxima in the Hough space, however these are not necessarily strictly increasing in their neighborhood. Below is a visualization of an Hough accumulator, the x-axis represents $\theta$ and the y-axis $\rho$, the more votes a line has, the brighter it is:</p>
<p><img src="data/hough0.png" alt="Hough Example"></p>
<p>If multiple lines need to be found, this requires finnicky searching through the Hough space and often leads to multiple line candidates per &ldquo;true&rdquo; line. For instance in OpenCV&rsquo;s implementation local maximas are found by <a href="https://github.com/opencv/opencv/blob/725e440d278aca07d35a5e8963ef990572b07316/modules/imgproc/src/hough.cpp#L95-L108">checking the 4-connected neighbors of a line</a>. There exists another, <a href="https://docs.opencv.org/4.7.0/dd/d1a/group__imgproc__feature.html#ga46b4e588934f6c8dfd509cc6e0e4545a">probabilistic implementation of the Hough transform</a>, however it also does not allow more control over the line picking.</p>
<h3 id="hough-pick-erase-and-repeat-">Hough, Pick, Erase and Repeat üîÅ</h3>
<p>A simple, but surprisingly robust method to find multiple lines boils down to the following steps:</p>
<ol>
<li>process the binarized image with the Hough transform</li>
<li>find the maximum in the Hough space or stop if the minimum requirements are not met for any line</li>
<li>remove the line from the binarized image and go to step 1</li>
</ol>
<p>(in a more sophisticated version a &ldquo;delta hough transform&rdquo; can be implemented and used to update the Hough space instead of recomputing it every step)</p>
<h3 id="demo">Demo</h3>
<p><img src="data/highway50_cropped.jpg" alt="Original Image"></p>
<p>(<a href="https://travelnevada.com/wp-content/uploads/2021/03/Highway50_Desktop.jpg">https://travelnevada.com/wp-content/uploads/2021/03/Highway50_Desktop.jpg</a>)</p>
<p>Processing above image with the described algorithm, we can generate the following images that show the intermediate steps (Hough space on the left, binarized image below). Notice that each line in the binarized image is removed and how the maxima plus more is disappearing in the Hough space every iteration. The script to generate the images including the Hough numpy implementation can be found <a href="data/simple_hough_multiline.py">here</a>.</p>
<p>Step #0</p>
<p><img src="data/iteration0.png" alt="Iteration 0"></p>
<p>Step #1</p>
<p><img src="data/iteration1.png" alt="Iteration 1"></p>
<p>Step #2</p>
<p><img src="data/iteration2.png" alt="Iteration 2"></p>
</div>


    </main>

    
  </body>
</html>
