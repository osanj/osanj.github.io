<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-us" lang="en-us">
<head>
  <link href="//gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="generator" content="Hugo 0.83.1" />

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>Notes on Homographies &middot; Just a Notepad</title>

  
  <link type="text/css" rel="stylesheet" href="https://osanj.github.io/css/print.css" media="print">
  <link type="text/css" rel="stylesheet" href="https://osanj.github.io/css/poole.css">
  <link type="text/css" rel="stylesheet" href="https://osanj.github.io/css/syntax.css">
  <link type="text/css" rel="stylesheet" href="https://osanj.github.io/css/hyde.css">
  
  <link type="text/css" rel="stylesheet" href="https://osanj.github.io/css/justified_text.css">
  
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Abril+Fatface|PT+Sans:400,400i,700">


  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-144-precomposed.png">
  <link rel="shortcut icon" href="/favicon.png">

  
  

  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css" integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js" integrity="sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js" integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous" onload="renderMathInElement(document.body);"></script>
  
</head>

  <body class=" ">
  <aside class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <a href="https://osanj.github.io/"><h1>Just a Notepad</h1></a>
      <p class="lead">
       For Stuff Worth Sharing 
      </p>
    </div>

    <nav>
      <ul class="sidebar-nav">
        <li><a href="https://osanj.github.io/">Home</a> </li>
        <li><a href="https://github.com/osanj/lava"> Lava </a></li><li><a href="/tags/"> Tags </a></li><li><a href="/about/"> About </a></li>
      </ul>
    </nav>

    <p>Â© 2020-2022 Jonas Schuepfer</p>
  </div>
</aside>

    <main class="content container">
    <div class="post">
  <h1>Notes on Homographies</h1>
  <time datetime=2021-12-27T00:00:00Z class="post-date">Mon, Dec 27, 2021</time>
  <p>This is writeup of some formulas that proofed to be helpful understanding and working with homographies.</p>

<p>It is based on some notes I made along the last few years. I apologize upfront for missing references and bad notation.</p>

<p>&nbsp;</p>

<h2 id="solving-for-a-homography-given-2d-correspondences">Solving for a Homography Given 2D Correspondences</h2>

<p>To solve for a homography 4 correspondences are required. Given the locations of these points it is possible to construct a linear
equation system and solve for the entries of the homography matrix.</p>

<p><figure><img src="data/homography_schema1.png" alt="Image correspondences"></figure></p>

<p>The relation between the image points and the homography is given by:</p>

<p><span  class="math">\[
\begin{aligned}
\begin{pmatrix} X_i \\ Y_i \end{pmatrix} = \Pi \left( H \begin{pmatrix} x_i \\ y_i \\ 1 \end{pmatrix} \right)
 = \Pi \left( \begin{pmatrix} h_{11} & h_{12} & h_{13} \\ h_{21} & h_{22} & h_{23} \\ h_{31} & h_{32} & h_{33} \end{pmatrix} \begin{pmatrix} x_i \\ y_i \\ 1 \end{pmatrix} \right)
\end{aligned}
\]</span></p>

<p>The homography is a 3x3 matrix which maps from the domain of <span  class="math">\(\left(\begin{smallmatrix} x_i \\ y_i \end{smallmatrix}\right)\)</span> to <span  class="math">\(\left(\begin{smallmatrix} X_i \\ Y_i \end{smallmatrix}\right)\)</span>. It works on homogeneous coordinates which is why a 1 was added above. <span  class="math">\(\Pi\)</span> denotes the perspective projection which maps 3d vectors into 2d by dividing by its third component:</p>

<p><span  class="math">\[
\begin{aligned}
\Pi \left( \begin{pmatrix} x \\ y \\ z \end{pmatrix} \right) &= \frac{1}{z} \begin{pmatrix} x \\ y \end{pmatrix} \\
\end{aligned}
\]</span></p>

<p>To use the correspondences of the target domain the perspective projection needs to be undone. Therefore we consider the direct output of the matrix multiplication with <span  class="math">\(H\)</span>:</p>

<p><span  class="math">\[
\begin{aligned}
\begin{pmatrix} \tilde{X}_i \\ \tilde{Y}_i \\ \tilde{Z}_i \end{pmatrix} = \begin{pmatrix} X_i \cdot \tilde{Z}_i \\ Y_i \cdot \tilde{Z}_i \\ \tilde{Z}_i \end{pmatrix} = H \begin{pmatrix} x_i \\ y_i \\ 1 \end{pmatrix}
\end{aligned}
\]</span></p>

<p>Now it is time to expand the matrix multiplication, so we get 3 equations:</p>

<p><span  class="math">\[
\begin{aligned}
X_i \cdot \tilde{Z}_i &= h_{11} x_i + h_{12} y_i + h_{13} \\
Y_i \cdot \tilde{Z}_i &= h_{21} x_i + h_{22} y_i + h_{23} \\
\tilde{Z}_i &= h_{31} x_i + h_{32} y_i + h_{33}
\end{aligned}
\]</span></p>

<p>The next steps are not that obvious IMO:</p>

<ol>
<li><p>Since the correspondences are only available in the 2d space the third equation above itself does not help to solve for unknowns, this means we have 2x4 equations for 9 unknowns and the solution is up to scale. In this case we can just fix one of the matrix values and be done with it, a common choice is <span  class="math">\(h_{33} = 1\)</span></p></li>

<li><p>With this additional constraint we can plug the equation for <span  class="math">\(\tilde{Z}_i\)</span> in the other equations and arrange them in a way that all <span  class="math">\(H\)</span> related terms are on one side and all other terms are on the opposite side</p></li>
</ol>

<p><span  class="math">\[
\begin{aligned}
\\
X_i \cdot \left( h_{31} x_i + h_{32} y_i + 1 \right) &= h_{11} x_i + h_{12} y_i + h_{13} \\
h_{31} x_i X_i + h_{32} y_i X_i + X_i &= h_{11} x_i + h_{12} y_i + h_{13} \\
X_i &= h_{11} x_i + h_{12} y_i + h_{13} - h_{31} x_i X_i - h_{32} y_i X_i \\ \\
Y_i \cdot \left( h_{31} x_i + h_{32} y_i + 1 \right) &= h_{21} x_i + h_{22} y_i + h_{23} \\
h_{31} x_i Y_i + h_{32} y_i X_i + Y_i &= h_{21} x_i + h_{22} y_i + h_{23} \\
Y_i &= h_{21} x_i + h_{22} y_i + h_{23} - h_{31} x_i Y_i - h_{32} y_i Y_i
\\
\end{aligned}
\]</span></p>

<p>With all four pairs of equations (<span  class="math">\(i = 1, 2, 3, 4\)</span>), it is possible to construct one large linear equation system where the unknown entries of the homography are stacked in a vector:</p>

<p><span  class="math">\[
\begin{pmatrix} X_1 \\ X_2 \\ X_3 \\ X_4 \\ Y_1 \\ Y_2 \\ Y_3 \\ Y_4 \end{pmatrix} =
\begin{pmatrix}
x_1 & y_1 & 1 & 0 & 0 & 0 & -x_1 X_1 & -y_1 X_1 \\
x_2 & y_2 & 1 & 0 & 0 & 0 & -x_2 X_2 & -y_2 X_2 \\
x_3 & y_3 & 1 & 0 & 0 & 0 & -x_3 X_3 & -y_3 X_3 \\
x_4 & y_4 & 1 & 0 & 0 & 0 & -x_4 X_4 & -y_4 X_4 \\
0 & 0 & 0 & x_1 & y_1 & 1 & -x_1 Y_1 & -y_1 Y_1 \\
0 & 0 & 0 & x_2 & y_2 & 1 & -x_2 Y_2 & -y_2 Y_2 \\
0 & 0 & 0 & x_3 & y_3 & 1 & -x_3 Y_3 & -y_3 Y_3 \\
0 & 0 & 0 & x_4 & y_4 & 1 & -x_4 Y_4 & -y_4 Y_4 \\
\end{pmatrix} \cdot
\begin{pmatrix} h_{11} \\ h_{12} \\ h_{13} \\ h_{21} \\ h_{22} \\ h_{23} \\ h_{31} \\ h_{32} \end{pmatrix}
\]</span></p>

<p>This is nice because now common math machinery can be thrown at this problem. The matrix needs to be inverted, then only a matrix multiplication is left to solve for the homography entries:</p>

<p><span  class="math">\[
\begin{aligned}
\vec{k} &= M \vec{h} \\
M^{-1}\vec{k} &= \vec{h}
\end{aligned}
\]</span></p>

<p>Once this is done the elements of <span  class="math">\(\vec{h}\)</span> and <span  class="math">\(h_{33}\)</span> (or whatever element was fixed) can be arranged into a matrix again. Then the homography can be used to project points from one domain to another. Of course, the usual requirements for matrix inversion also apply here, i.e. <span  class="math">\(M\)</span> needs to exhibit linear independence, for instance this is not given if two correspondence pairs are identical.</p>

<p>This kind of approach is called <em>Direct Linear Transform</em> (DLT) in literature. It is only a viable approach if the correspondences are sufficiently precise. Robust homography estimation is usually done with more than 4 correspondences and using RANSAC-style methods which can cope with incorrect correspondences.</p>

<p>To conclude, here is an implementation in Python:</p>

<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Python" data-lang="Python"><span style="color:#f92672">from</span> typing <span style="color:#f92672">import</span> Optional
<span style="color:#f92672">import</span> numpy <span style="color:#f92672">as</span> np

<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">dlt</span>(src: np<span style="color:#f92672">.</span>ndarray, dst: np<span style="color:#f92672">.</span>ndarray) <span style="color:#f92672">-&gt;</span> Optional[np<span style="color:#f92672">.</span>ndarray]:
    <span style="color:#66d9ef">assert</span> src<span style="color:#f92672">.</span>shape <span style="color:#f92672">==</span> (<span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">2</span>)
    <span style="color:#66d9ef">assert</span> dst<span style="color:#f92672">.</span>shape <span style="color:#f92672">==</span> (<span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">2</span>)

    m <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>zeros((<span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">8</span>))
    m[<span style="color:#ae81ff">0</span>:<span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> m[<span style="color:#ae81ff">4</span>:<span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">3</span>] <span style="color:#f92672">=</span> src[:, <span style="color:#ae81ff">0</span>]
    m[<span style="color:#ae81ff">0</span>:<span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> m[<span style="color:#ae81ff">4</span>:<span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">4</span>] <span style="color:#f92672">=</span> src[:, <span style="color:#ae81ff">1</span>]
    m[<span style="color:#ae81ff">0</span>:<span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">2</span>] <span style="color:#f92672">=</span> m[<span style="color:#ae81ff">4</span>:<span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">5</span>] <span style="color:#f92672">=</span> src[:, <span style="color:#ae81ff">2</span>]
    m[<span style="color:#ae81ff">0</span>:<span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">6</span>] <span style="color:#f92672">=</span> <span style="color:#f92672">-</span> src[:, <span style="color:#ae81ff">0</span>] <span style="color:#f92672">*</span> dst[:, <span style="color:#ae81ff">0</span>]
    m[<span style="color:#ae81ff">0</span>:<span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">7</span>] <span style="color:#f92672">=</span> <span style="color:#f92672">-</span> src[:, <span style="color:#ae81ff">1</span>] <span style="color:#f92672">*</span> dst[:, <span style="color:#ae81ff">0</span>]
    m[<span style="color:#ae81ff">4</span>:<span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">6</span>] <span style="color:#f92672">=</span> <span style="color:#f92672">-</span> src[:, <span style="color:#ae81ff">0</span>] <span style="color:#f92672">*</span> dst[:, <span style="color:#ae81ff">1</span>]
    m[<span style="color:#ae81ff">4</span>:<span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">7</span>] <span style="color:#f92672">=</span> <span style="color:#f92672">-</span> src[:, <span style="color:#ae81ff">1</span>] <span style="color:#f92672">*</span> dst[:, <span style="color:#ae81ff">1</span>]

    <span style="color:#66d9ef">try</span>:
        m_inv <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>linalg<span style="color:#f92672">.</span>inv(m)
    <span style="color:#66d9ef">except</span> np<span style="color:#f92672">.</span>linalg<span style="color:#f92672">.</span>LinAlgError:
        <span style="color:#66d9ef">return</span> None

    k <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>concatenate((dst[:, <span style="color:#ae81ff">0</span>], dst[:, <span style="color:#ae81ff">1</span>]))
    h <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>dot(m_inv, k)
    <span style="color:#66d9ef">return</span> np<span style="color:#f92672">.</span>reshape(np<span style="color:#f92672">.</span>concatenate((h, [<span style="color:#ae81ff">1</span>])), (<span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">3</span>))</code></pre></div>

<p>&nbsp;</p>

<h2 id="transforming-existing-homographies">Transforming Existing Homographies</h2>

<h3 id="use-a-homography-for-different-scales">Use a Homography for Different Scales</h3>

<p>Consider a homography is computed on a certain scale, but it is used on a different scale. A concrete example is running tracking algorithms (e.g. keypoint based) on a smaller scale than the input to keep everything efficient, but then doing some kind of visualization on the original scale:</p>

<p><figure><img src="data/homography_schema2.png" alt="Scaled Images"></figure></p>

<p>Consider points that are on a different scale relative to the scale where the homography was computed on:</p>

<p><span  class="math">\[
\begin{aligned}
\begin{pmatrix} X^\prime \\ Y^\prime \end{pmatrix} &= s_1 \begin{pmatrix} X \\ Y \end{pmatrix} \\ \\
\begin{pmatrix} x^\prime \\ y^\prime \end{pmatrix} &= s_2 \begin{pmatrix} x \\ y \end{pmatrix}
\end{aligned}
\]</span></p>

<p>The objective is now to transform the homography in a way that the scaling does not need to be done before/after applying the homography. For starters let's plug the scaled version into the basic equation:</p>

<p><span  class="math">\[
\begin{aligned}
\frac{1}{s_1} \begin{pmatrix} X^\prime \\ Y^\prime \end{pmatrix} = \Pi \left( H \frac{1}{s_2} \begin{pmatrix} x^\prime \\ y^\prime \\ s_2 \end{pmatrix} \right)
\end{aligned}
\]</span></p>

<p>When expanding the equation, <span  class="math">\(\frac{1}{s_1}\)</span> can be moved on the other side while maintaining the original structure of the equation:</p>

<p><span  class="math">\[
\begin{aligned}
\begin{pmatrix} X^\prime \\ Y^\prime \end{pmatrix} &= s_1 \Pi \left( H \frac{1}{s_2} \begin{pmatrix} x^\prime \\ y^\prime \\ s_2 \end{pmatrix} \right) \\
&= s_1 \Pi \left( \begin{pmatrix} \frac{1}{s_2} h_{11} x^\prime + \frac{1}{s_2} h_{12} y^\prime + h_{13} \\ \frac{1}{s_2} h_{21} x^\prime + \frac{1}{s_2} h_{22} y^\prime + h_{23} \\ \frac{1}{s_2} h_{31} x^\prime + \frac{1}{s_2} h_{32} y^\prime + h_{33} \end{pmatrix} \right) \\
&= s_1 \frac{1}{\frac{1}{s_2} h_{31} x^\prime + \frac{1}{s_2} h_{32} y^\prime + h_{33}} \begin{pmatrix} \frac{1}{s_2} h_{11} x^\prime + \frac{1}{s_2} h_{12} y^\prime + h_{13} \\ \frac{1}{s_2} h_{21} x^\prime + \frac{1}{s_2} h_{22} y^\prime + h_{23} \end{pmatrix} \\
&= \frac{1}{\frac{1}{s_2} h_{31} x^\prime + \frac{1}{s_2} h_{32} y^\prime + h_{33}} \begin{pmatrix} \frac{s_1}{s_2} h_{11} x^\prime + \frac{s_1}{s_2} h_{12} y^\prime + s_1 h_{13} \\ \frac{s_1}{s_2} h_{21} x^\prime + \frac{s_1}{s_2} h_{22} y^\prime + s_1 h_{23} \end{pmatrix} \\
&= \Pi \left( H_s \begin{pmatrix} x^\prime \\ y^\prime \\ 1 \end{pmatrix} \right)
\end{aligned}
\]</span></p>

<p>Now it is possible to read off the entries of a modified homography <span  class="math">\(H_s\)</span> that maps between the scaled domains:</p>

<p><span  class="math">\[
H_s = \begin{pmatrix}
\frac{s_1}{s_2} h_{11} & \frac{s_1}{s_2} h_{12} & s_1 h_{13} \\
\frac{s_1}{s_2} h_{21} & \frac{s_1}{s_2} h_{22} & s_1 h_{23} \\
\frac{1}{s_2} h_{31} & \frac{1}{s_2} h_{32} & h_{33}
\end{pmatrix}
\]</span></p>

<p>This is a generalization of a <a href="https://stackoverflow.com/a/48915151">Stackoverflow answer</a> I submitted some years ago (on Stackoverflow only the case <span  class="math">\(s = s_1 = s_2\)</span> is covered and the usage of scales is inverted). Depending on the exact usecase doing the computations on the original scale and only scaling the resulting geometry to your desired scale might be more straightforward. Also recomputing the homography with the DLT instead of modifying the existing one is an easy option. However, if you feel nerdy and want to make your code harder to read feel free to use this ð</p>

<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Python" data-lang="Python"><span style="color:#f92672">import</span> numpy <span style="color:#f92672">as</span> np

<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">scale_homography</span>(h: np<span style="color:#f92672">.</span>ndarray, s_src: float,
                     s_dst: float) <span style="color:#f92672">-&gt;</span> np<span style="color:#f92672">.</span>ndarray:
    <span style="color:#66d9ef">assert</span> h<span style="color:#f92672">.</span>shape <span style="color:#f92672">==</span> (<span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">3</span>)
    h2 <span style="color:#f92672">=</span> h<span style="color:#f92672">.</span>copy()
    h2[:<span style="color:#ae81ff">2</span>, :] <span style="color:#f92672">/=</span> s_src
    h2[:, :<span style="color:#ae81ff">2</span>] <span style="color:#f92672">*=</span> s_dst
    <span style="color:#66d9ef">return</span> h2</code></pre></div>

<p>&nbsp;</p>

<h3 id="use-a-homography-for-a-shifted-anchor">Use a Homography for a Shifted Anchor</h3>

<p>Consider a homography is computed for a quad correspondence and the objective is to warp images into the original image <em>outside</em> of the quad. When using <a href="https://docs.opencv.org/4.5.5/da/d54/group__imgproc__transform.html#gaf73673a7e8e18ec6963e3774e6a94b87"><code>cv.warpPerspective</code></a> it is only possible to warp to the right and bottom of the original domain, essentially everywhere where pixel indices are positive (remember that image coordinate systems are in the top left, positive x is rightwards and positive y is downwards). A remedy to this is to compute a homography which does already cover area to the left and top of the original quad.</p>

<p><figure><img src="data/homography_schema3.png" alt="Shifted Homography"></figure></p>

<p>This time it is only required to introduce new variables for the source domain:</p>

<p><span  class="math">\[
\begin{pmatrix} x^\prime \\ y^\prime \end{pmatrix} = \begin{pmatrix} x + t_x \\ y + t_y \end{pmatrix}
\]</span></p>

<p>The modus operandi remains the same, let's plug this new relation in the basic equation, rearrange and read off the new homography:</p>

<p><span  class="math">\[
\begin{aligned}
\begin{pmatrix} X \\ Y \end{pmatrix} &= \Pi \left( H \begin{pmatrix} x^\prime - t_x \\ y^\prime - t_y \\ 1 \end{pmatrix} \right) \\
&= \Pi \left( \begin{pmatrix} h_{11} \left( x^\prime - t_x \right) + h_{12} \left( y^\prime - t_y \right) + h_{13} \\ h_{21} \left( x^\prime - t_x \right) + h_{22} \left( y^\prime - t_y \right) + h_{23} \\ h_{31} \left( x^\prime - t_x \right) + h_{32} \left( y^\prime - t_y \right) + h_{33} \end{pmatrix} \right) \\
&= \Pi \left( \begin{pmatrix} h_{11} x^\prime + h_{12} y^\prime + h_{13} - h_{11} t_x - h_{12} t_y \\ h_{21} x^\prime + h_{22} y^\prime + h_{23} - h_{21} t_x - h_{22} t_y \\ h_{31} x^\prime + h_{32} y^\prime + h_{33} - h_{31} t_x - h_{32} t_y \end{pmatrix} \right) \\
&= \Pi \left( H_t \begin{pmatrix} x^\prime \\ y^\prime \\ 1 \end{pmatrix} \right)
\end{aligned}
\]</span></p>

<p>In this case the modified homography is:</p>

<p><span  class="math">\[
H_t = \begin{pmatrix}
h_{11} & h_{12} & h_{13} - h_{11} t_x - h_{12} t_y \\
h_{21} & h_{22} & h_{23} - h_{21} t_x - h_{22} t_y \\
h_{31} & h_{32} & h_{33} - h_{31} t_x - h_{32} t_y
\end{pmatrix}
\]</span></p>

<p>For this usecase a pragmatic, less elegant alternative exists as well. One can project the 4 vertices of the image to be warped using the initial homography. After that one can recompute the homography using the corners of the warp image and the projected vertices as correspondences with the DLT.</p>

<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Python" data-lang="Python"><span style="color:#f92672">import</span> numpy <span style="color:#f92672">as</span> np

<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">shift_homograpy</span>(h: np<span style="color:#f92672">.</span>ndarray, tx: float,
                    ty: float) <span style="color:#f92672">-&gt;</span> np<span style="color:#f92672">.</span>ndarray:
    <span style="color:#66d9ef">assert</span> h<span style="color:#f92672">.</span>shape <span style="color:#f92672">==</span> (<span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">3</span>)
    h2 <span style="color:#f92672">=</span> h<span style="color:#f92672">.</span>copy()
    h2[:, <span style="color:#ae81ff">2</span>] <span style="color:#f92672">-=</span> h2[:, <span style="color:#ae81ff">0</span>] <span style="color:#f92672">*</span> tx <span style="color:#f92672">+</span> h2[:, <span style="color:#ae81ff">0</span>] <span style="color:#f92672">*</span> tx <span style="color:#f92672">+</span> h2[:, <span style="color:#ae81ff">1</span>] <span style="color:#f92672">*</span> ty
    <span style="color:#66d9ef">return</span> h2</code></pre></div>
</div>


    </main>

    
  </body>
</html>
